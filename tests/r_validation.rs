//! Tests that validate gamlss_rs results against pre-computed R gamlss fixtures.
//!
//! Fixtures in tests/fixtures/*.json were generated by generate_fixtures.R (not run in CI).
//! Each fixture contains input data, R fitted values, coefficients, and EDF.

mod common;

use gamlss_rs::distributions::{Gamma, Gaussian, NegativeBinomial, Poisson, StudentT};
use gamlss_rs::{DataSet, Formula, GamlssModel, Smooth, Term};
use ndarray::Array1;
use serde::Deserialize;
use std::collections::HashMap;

#[derive(Deserialize)]
#[allow(dead_code)]
struct Fixture {
    scenario: String,
    n_obs: usize,
    data: HashMap<String, Vec<f64>>,
    r_results: RResults,
}

#[derive(Deserialize)]
struct RResults {
    converged: bool,
    #[serde(default)]
    coefficients: HashMap<String, CoefValue>,
    fitted_mu: Vec<f64>,
    edf: HashMap<String, f64>,
}

/// R can encode coefficients as either a single number or an array.
#[derive(Deserialize, Clone, Debug)]
#[serde(untagged)]
enum CoefValue {
    Scalar(f64),
    Array(Vec<f64>),
}

impl CoefValue {
    fn to_vec(&self) -> Vec<f64> {
        match self {
            CoefValue::Scalar(v) => vec![*v],
            CoefValue::Array(v) => v.clone(),
        }
    }
}

/// Loads a fixture JSON file from the fixtures directory.
fn load_fixture(name: &str) -> Fixture {
    let path = format!(
        "{}/tests/fixtures/{}.json",
        env!("CARGO_MANIFEST_DIR"),
        name
    );
    let content = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {}: {}", path, e));
    serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse fixture {}: {}", name, e))
}

/// Builds a response vector and predictor DataSet from raw data.
///
/// Extracts the response variable (y_key) and creates a DataSet with remaining columns as predictors.
fn build_dataset(data: &HashMap<String, Vec<f64>>, y_key: &str) -> (Array1<f64>, DataSet) {
    let y = Array1::from_vec(data[y_key].clone());
    let mut ds = DataSet::new();
    for (key, values) in data {
        if key != y_key {
            ds.insert_column(key.clone(), Array1::from_vec(values.clone()));
        }
    }
    (y, ds)
}

/// Computes Pearson correlation coefficient between two vectors.
fn correlation(a: &[f64], b: &[f64]) -> f64 {
    let n = a.len() as f64;
    let mean_a: f64 = a.iter().sum::<f64>() / n;
    let mean_b: f64 = b.iter().sum::<f64>() / n;
    let mut cov = 0.0;
    let mut var_a = 0.0;
    let mut var_b = 0.0;
    for (ai, bi) in a.iter().zip(b.iter()) {
        let da = ai - mean_a;
        let db = bi - mean_b;
        cov += da * db;
        var_a += da * da;
        var_b += db * db;
    }
    cov / (var_a.sqrt() * var_b.sqrt())
}

/// Computes the maximum relative error between two vectors.
///
/// Returns `max_i(|a[i] - b[i]| / max(|a[i]|, 1e-10))` to handle near-zero values gracefully.
fn max_relative_error(a: &[f64], b: &[f64]) -> f64 {
    a.iter()
        .zip(b.iter())
        .map(|(ai, bi)| {
            let denom = ai.abs().max(1e-10);
            (ai - bi).abs() / denom
        })
        .fold(0.0_f64, f64::max)
}

// =============================================================================
// Linear scenario tests — compare coefficients, fitted values, and EDF
// =============================================================================

#[test]
fn test_r_gaussian_linear() {
    let fix = load_fixture("gaussian_linear");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        )
        .with_terms("sigma", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &Gaussian::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    // Fitted mu correlation
    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "Gaussian linear: fitted mu correlation {:.6} < 0.999",
        corr
    );

    // Coefficient comparison
    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "Gaussian linear: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );

    // EDF comparison
    let r_mu_edf = fix.r_results.edf["mu"];
    let rs_mu_edf = model.models["mu"].edf;
    assert!(
        (r_mu_edf - rs_mu_edf).abs() < 1.0,
        "Gaussian linear: mu EDF diff {:.2} >= 1.0 (R={}, rs={})",
        (r_mu_edf - rs_mu_edf).abs(),
        r_mu_edf,
        rs_mu_edf
    );
}

#[test]
fn test_r_gaussian_heteroskedastic() {
    let fix = load_fixture("gaussian_heteroskedastic");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        )
        .with_terms(
            "sigma",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        );

    let model = GamlssModel::fit(&y, &data, &formula, &Gaussian::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "Gaussian heteroskedastic: fitted mu correlation {:.6} < 0.999",
        corr
    );

    // Mu coefficients
    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "Gaussian heteroskedastic: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );

    // Sigma coefficients
    let r_sigma_coefs = fix.r_results.coefficients["sigma"].to_vec();
    let rs_sigma_coefs: Vec<f64> = model.models["sigma"].coefficients.to_vec();
    let sigma_rel_err = max_relative_error(&r_sigma_coefs, &rs_sigma_coefs);
    assert!(
        sigma_rel_err < 0.05,
        "Gaussian heteroskedastic: sigma coef max relative error {:.4} >= 0.05",
        sigma_rel_err
    );
}

#[test]
fn test_r_poisson_linear() {
    let fix = load_fixture("poisson_linear");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new().with_terms(
        "mu",
        vec![
            Term::Intercept,
            Term::Linear {
                col_name: "x".to_string(),
            },
        ],
    );

    let model = GamlssModel::fit(&y, &data, &formula, &Poisson::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "Poisson linear: fitted mu correlation {:.6} < 0.999",
        corr
    );

    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "Poisson linear: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );
}

#[test]
fn test_r_gamma_linear() {
    let fix = load_fixture("gamma_linear");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        )
        .with_terms("sigma", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &Gamma::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "Gamma linear: fitted mu correlation {:.6} < 0.999",
        corr
    );

    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "Gamma linear: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );

    let r_mu_edf = fix.r_results.edf["mu"];
    let rs_mu_edf = model.models["mu"].edf;
    assert!(
        (r_mu_edf - rs_mu_edf).abs() < 1.0,
        "Gamma linear: mu EDF diff {:.2} >= 1.0",
        (r_mu_edf - rs_mu_edf).abs()
    );
}

#[test]
fn test_r_negative_binomial_linear() {
    let fix = load_fixture("negative_binomial_linear");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        )
        .with_terms("sigma", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &NegativeBinomial::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "NegBin linear: fitted mu correlation {:.6} < 0.999",
        corr
    );

    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "NegBin linear: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );
}

#[test]
fn test_r_studentt_linear() {
    let fix = load_fixture("studentt_linear");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![
                Term::Intercept,
                Term::Linear {
                    col_name: "x".to_string(),
                },
            ],
        )
        .with_terms("sigma", vec![Term::Intercept])
        .with_terms("nu", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &StudentT::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.999,
        "StudentT linear: fitted mu correlation {:.6} < 0.999",
        corr
    );

    let r_mu_coefs = fix.r_results.coefficients["mu"].to_vec();
    let rs_mu_coefs: Vec<f64> = model.models["mu"].coefficients.to_vec();
    let rel_err = max_relative_error(&r_mu_coefs, &rs_mu_coefs);
    assert!(
        rel_err < 0.05,
        "StudentT linear: mu coef max relative error {:.4} >= 0.05",
        rel_err
    );
}

// =============================================================================
// Smooth scenario tests — compare only fitted values (different basis types)
// =============================================================================

#[test]
fn test_r_gaussian_smooth() {
    let fix = load_fixture("gaussian_smooth");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![Term::Smooth(Smooth::PSpline1D {
                col_name: "x".to_string(),
                n_splines: 20,
                degree: 3,
                penalty_order: 2,
            })],
        )
        .with_terms("sigma", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &Gaussian::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.99,
        "Gaussian smooth: fitted mu correlation {:.6} < 0.99",
        corr
    );

    // EDF with relaxed threshold — different basis types yield different complexity
    let r_mu_edf = fix.r_results.edf["mu"];
    let rs_mu_edf = model.models["mu"].edf;
    assert!(
        (r_mu_edf - rs_mu_edf).abs() < 5.0,
        "Gaussian smooth: mu EDF diff {:.2} >= 5.0 (R={:.2}, rs={:.2})",
        (r_mu_edf - rs_mu_edf).abs(),
        r_mu_edf,
        rs_mu_edf
    );
}

#[test]
fn test_r_poisson_smooth() {
    let fix = load_fixture("poisson_smooth");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new().with_terms(
        "mu",
        vec![Term::Smooth(Smooth::PSpline1D {
            col_name: "x".to_string(),
            n_splines: 20,
            degree: 3,
            penalty_order: 2,
        })],
    );

    let model = GamlssModel::fit(&y, &data, &formula, &Poisson::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.99,
        "Poisson smooth: fitted mu correlation {:.6} < 0.99",
        corr
    );
}

#[test]
fn test_r_gamma_smooth() {
    let fix = load_fixture("gamma_smooth");
    assert!(fix.r_results.converged);

    let (y, data) = build_dataset(&fix.data, "y");
    let formula = Formula::new()
        .with_terms(
            "mu",
            vec![Term::Smooth(Smooth::PSpline1D {
                col_name: "x".to_string(),
                n_splines: 20,
                degree: 3,
                penalty_order: 2,
            })],
        )
        .with_terms("sigma", vec![Term::Intercept]);

    let model = GamlssModel::fit(&y, &data, &formula, &Gamma::new()).unwrap();
    assert!(model.converged(), "gamlss_rs did not converge");

    let fitted: Vec<f64> = model.models["mu"].fitted_values.to_vec();
    let corr = correlation(&fitted, &fix.r_results.fitted_mu);
    assert!(
        corr > 0.99,
        "Gamma smooth: fitted mu correlation {:.6} < 0.99",
        corr
    );
}
